# 浏览器工作原理

简单来说，浏览器的核心任务是加载用户指定的网址（URI，统一资源标识符），然后将网页资源展示在浏览器窗口中。作为前端开发者，了解浏览器的结构有助于我们在开发过程中做出最优选择。

## 浏览器介绍

目前，市面上主要有五种[主流浏览器](https://gs.statcounter.com/)：Chrome、Safari、Edge、Opera 和 Firefox。这些浏览器使用不同的渲染引擎：

Blink引擎：由谷歌开发的Chromium浏览器项目采用Blink作为其渲染引擎，Blink 最初是从 WebKit 中分离出来的。除了Chrome，Microsoft Edge、Opera、Vivaldi等浏览器也使用Chromium作为基础，搭载了Blink渲染引擎。

WebKit引擎：最初由苹果开发并用于Safari浏览器的开源渲染引擎。尽管曾经基于WebKit开发过Chrome浏览器，但Chrome现已转向Blink引擎。

Gecko引擎：由Mozilla基金会开发的开源渲染引擎，一直用于Mozilla Firefox浏览器。

Trident引擎：由Microsoft开发的浏览器渲染引擎，曾用于Internet Explorer浏览器。但随着Microsoft Edge转向基于Chromium，Trident引擎的使用逐渐减少，新版Edge浏览器采用了Chromium的Blink引擎。

这些渲染引擎的不同选择对于前端开发者来说具有重要意义，因为它们在浏览器的行为和特性上会有一些差异。



### 浏览器发展过程

在2007年之前，市面上的浏览器通常采用单进程架构。这种单进程浏览器具有以下特点：

1. 不稳定：如果进程中的任何一个线程执行出错，整个进程可能会崩溃，导致浏览器不稳定。
2. 不流畅：在关闭进程之后，操作系统才会回收进程占用的内存。单进程浏览器无法主动回收内存，必须关闭浏览器才能回收内存。
3. 不安全：单进程浏览器中的页面可以获取浏览器的全部权限（恶意程序获取系统权限），甚至可能攻击操作系统，造成安全隐患。

为了解决这些问题，现代浏览器采用了多进程架构，并通过安全沙箱解决安全问题（恶意程序也无法突破沙箱获取系统权限）。以Chrome为例，它于2008年引入了多进程架构。在多进程架构下，浏览器由多个独立的进程组成，彼此隔离，不会相互影响。每个进程包含多个线程，协同工作完成各自的任务。打开一个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共计4个进程。如果页面使用插件，还需要额外的插件进程（查看浏览器进程数可通过【页面右上角的三个点点点 -> 更多工具 -> 任务管理器】可打开相关面板）。

尽管多进程架构解决了不稳定和不流畅的问题，但也带来了更高的资源消耗。每个进程都包含一些公共基础结构的副本，因此浏览器会占用更多内存资源。为应对这一挑战，Chrome团队于2016年引入了"面向服务的架构"（SOA）思想，将Chrome的架构转向更灵活和可维护的方向。

在SOA架构下，Chrome将各模块拆分为独立的服务，每个服务提供特定功能，并通过网络通信。这提高了系统的可扩展性和灵活性。Chrome还采用了弹性架构，根据设备性能决定是否将服务整合到一个进程中，以节省内存。

这一演进使Chrome更趋向于现代操作系统的面向服务的架构，以满足其简单、稳定、高效和安全的目标。

### iframe的渲染方式

从 Chrome 67 起，引入了默认启用的 Site Isolation 机制，以增强 iframe 渲染的安全性。这一机制使得在同一标签页（Tab）中的跨站 iframe 使用单独的渲染进程进行渲染，从而提高了浏览器的安全性。[查看原理图](https://static.geekbang.org/infoq/5bee72864411e.png)

Site Isolation 并不是简单的多进程叠加，它在底层重新定义了 iframe 之间的通信方式，并对 Chrome 的其他功能进行了相应的调整和优化，以确保整体性能和安全性得到提升。要深入了解 Site Isolation，可以参考[这里](https://developers.google.com/web/updates/2018/07/site-isolation)。

### service worker 是否存在于渲染引擎中

Service workers 是一种后台执行的 JavaScript 脚本，用于异步处理网络请求拦截、消息推送、离线缓存等任务，而不阻塞各个 Tab 渲染进程的运行。这种设计使得 Service workers 可以在不干扰用户界面渲染的情况下提高网站的性能和安全性，并且即使 Tab 被关闭，它们也能够继续工作。需要注意的是，Service workers 无法直接访问页面的 DOM 结构。

因此 Service workers 在浏览器中运行时通常不在渲染进程中执行，也不是单独开辟一个渲染进程，而是运行在浏览器的后台线程中，独立于渲染进程。



## 请求链路

当在浏览器地址栏中输入 google.com 并按下回车键时，浏览器经历了一系列步骤，从开始加载到页面展示只需要短短几秒。下面我们来详细了解浏览器在这个过程中都做了些什么。

### 资源加载阶段

1. beforeunload 事件检查: 当用户按下回车键后，浏览器会首先触发当前页面的 beforeunload 事件，如果当前页面有监听该事件并且用户同意继续，浏览器才会继续加载新页面。
2. URL 解析与 DNS 查询: 用户输入的 URL 会传递给浏览器的主进程，主进程会解析 URL，包括自动补全协议、端口等，以确定要访问的协议、主机名、端口号等信息。然后，浏览器执行 DNS 查询，将主机名解析为对应的 IP 地址。
3. 缓存检查: 浏览器在发送网络请求之前，进行缓存检查。缓存分为强缓存和协商缓存，它们决定了是否需要实际发送请求到服务器。这里是进行强缓存检测。如果缓存有效，资源将直接从本地缓存获取，无需建立 TCP 连接。
4. 建立 TCP 连接: 如果资源的强缓存未命中或已过期，主进程会通知渲染进程，渲染进程通知网络进程，开始建立 TCP 连接，这是获取资源的必要步骤。
5. TLS 握手（仅适用于 HTTPS）: 如果请求协议是 HTTPS，浏览器需要建立 TLS 加密连接。TLS握手是客户端和服务器之间会协商加密算法、交换密钥，其核心是加密HTTP报文给TCP传输，保障数据的安全。TLS 握手在建立 TCP 连接后执行。
6. 发起 HTTP 请求: 一旦 TCP 连接和可能的 TLS 连接建立，浏览器构建 HTTP 请求，包括请求方法（如 GET、POST）、URL、请求头和请求体等信息。浏览器通过已建立的 TCP 连接将该请求发送给服务器。
7. 协商缓存检查: 如果请求包含协商缓存条件头（如 If-Modified-Since 或 If-None-Match），服务器会检查资源是否有变化。如果没有变化，服务器返回 304 Not Modified 响应，告诉浏览器可以使用本地缓存。
8. 获取新资源: 如果强缓存未命中或已过期，服务器会返回新的资源，包括 HTML、CSS、JavaScript、图像等。
9. 更新强缓存: 浏览器将新获取的资源更新到本地缓存中并更新 Cache-Control 或 Expires 字段。
10. 更新协商缓存条件: 浏览器更新协商缓存请求头，If-Modified-Since 或 If-None-Match更新为服务器最新生成的资源标识符（Etag），以便进行下一次协商缓存验证。
11. 处理响应数据: 浏览器根据响应头中的 Content-Type 字段来判断响应的数据类型，决定如何处理响应体的内容。根据 Content-Type 的值，浏览器可以将响应渲染成 HTML 页面、json数据、或者作为下载类型处理。
12. 断开TCP连接

以上过程都是在主进程和网络进程中执行的，渲染阶段将在渲染进程中执行。

### 资源渲染阶段

浏览器的渲染进程接收到服务器的响应后，开始解析HTML、CSS和JavaScript，构建网页DOM树和渲染树，然后将网页内容显示在用户的屏幕上，需要注意的是渲染引擎是单线程。

1. 解析HTML： 渲染进程收到HTML响应后，HTML解析器开始解析HTML文档。这包括识别文档的字符编码，构建DOM（Document Object Model）树，DOM由 W3C 组织指定的。它是HTML文档的抽象表示，它以树状结构表示文档的元素、属性和内容，它是操作文档的通用规范。DOM 是由 W3C 组织指定的。
   * 如果在 html 中存在 `<img>` `<link>` 等标签，渲染进程会将这些任务转交给网络进程进行相关资源的下载。`<img>`和`<link>`的加载通常不会阻塞渲染进程，但可能会影响页面的呈现速度和用户体验，特别是在资源较大或网络速度较慢的情况下。优化加载顺序和资源大小可以改善页面加载性能。
   * 当解析器到达 `<script>` 标记时立即解析并执行脚本。文档的解析将停止，直到脚本被执行。如果脚本是外部的，则必须首先从网络获取资源 （这也是同步完成的），并且解析将停止，直到获取资源为止。停止解析 html 的原因在于 JS 可能会改变 DOM 的结构。如果在脚本中添加“defer”属性，这样脚本就不会停止文档解析，而是在文档解析完成后执行。defer 属性只对外部脚本（使用 src 属性引用的脚本文件）有效，对于内联脚本（直接在 `<script>` 标签中编写的脚本）defer 属性将被忽略。
   * 若需要实现异步 HTML5 添加了一个选项 async 来将脚本标记为异步，这样它将由不同的线程解析和执行。但该脚本不能修改 DOM 树。
   * `<script>`在未开启defer与async的情况下一般需要将script脚本放在文档底部，而不会阻塞页面解析和渲染。
   * 浏览器会在解析 `<style>` 标签时也会阻塞 DOM 的解析和渲染。但 CSS 必须优先于 DOM 加载，主要原因是为了避免页面出现无样式内容的瞬间闪烁（FOUC，Flash of Unstyled Content）。对于这种问题一般有两种处理方式：
     1. 将 `<style>` 标签放在 `<head>` 部分（`<head>` 标签中的内容会被先解析和执行，然后才会继续解析和执行 `<body>` 标签中的内容），可以确保 CSS 规则尽早加载和解析，避免在 DOM 解析和渲染过程中造成延迟。
     2. 将 CSS 规则放在外部的 CSS 文件中，并通过 `<link>` 标签将其引入到 HTML 文档中。link标签加上rel="preload"属性，确保渲染之前提前加载资源。
2. 解析CSS： 渲染进程会继续解析CSS文件，以确定如何渲染页面。这包括识别样式规则、计算元素的样式和确定元素的大小和位置。HTML 和 CSS 规范由 W3C（万维网联盟）组织维护。
3. 构建渲染树： 浏览器使用DOM树和CSS样式信息来构建渲染树（也称为渲染对象树或布局树）。但它并不包括所有的DOM元素。一些不可见的元素如display: none的元素不会出现在渲染树中，而visibility: hidden和opacity: 0的元素会出现在渲染树中，但在绘制阶段不可见。
4. 分层（Layering）： 在渲染树构建之后，浏览器会将元素分层。分层让浏览器更有效地管理页面，减少重绘和回流的开销，使得浏览器可以更精确地重绘和回流需要变化的部分，而不是整个页面。某些图层可以受益于硬件加速，这意味着它们的渲染可以由GPU执行，而不是CPU。若要查看浏览器分层情况，您可以打开开发者模式并导航至“More tools” -> “Layers”。
5. 布局（Layout）： 一旦有了渲染树，浏览器引擎会执行布局过程。布局过程确定了每个元素在视口中的确切位置和大小。这包括计算元素的边距、边框、填充以及相对于父元素的位置。盒模型的定义在这一览无余。
   * HTML 使用基于流的布局模型，“流程中”较晚的元素通常不会影响“流程中”较早的元素的几何形状，因此布局可以在文档中从左到右、从上到下进行。
   * 布局是一个递归过程，它从根渲染器开始，通常对应于 HTML 文档的 `<html>` 元素。在布局过程中，浏览器会递归遍历渲染树（Render Tree）的各个节点，为每个渲染器计算几何信息，包括位置、尺寸、边距、填充等。这个过程确保了页面上的元素按照正确的规则进行排列和布局。
6. 绘制（Paint）： 一旦布局完成，渲染进程会遍历渲染树并执行绘制操作，将页面的内容绘制到屏幕上。这包括填充元素的背景颜色、绘制文本、边框等。如果是矢量图就直接显示在屏幕上，不需要走栅格化和合成的流程。
   * 栅格化（Rasterization）： 绘制阶段的一个子步骤，栅格化是将这些复杂效果转化为像素形式存储在内存中，以供合成使用。比如将图形操作转化成像素信息的过程。在某些情况下，栅格化可以借助图形处理单元（GPU）来执行，这可以显著提高性能。但是矢量图和普通的css样式不需要像栅格图像一样经过栅格化的过程。
   * 合成（Compositing）：绘制阶段的一个子步骤，合成的主要任务是将已经经过栅格化的图像合并，包括处理多层嵌套元素之间的关系，以产生最终的视觉效果。矢量图形通常在渲染过程的早期阶段直接呈现，所以也不需要经过合成阶段。
   * 显示：绘制阶段的一个子步骤，浏览器将合成的图像传递给计算机的GPU（图形处理单元），由GPU负责将图像显示在用户的屏幕上。
   * 布局确定了页面中元素的位置和大小不涉及绘制像素，而绘制是将这些元素渲染成可视的像素。布局是一种确定元素在页面上的占位和相对位置的过程，而绘制是将这些占位元素渲染成实际的图像以供用户看到。
7. 回流和重绘： 当用户与页面交互或页面内容发生变化时，浏览器可能需要重新执行部分或全部渲染流程。这可能包括重新布局、重新绘制操作。

需要注意的是渲染引擎采用了一种称为"渐进式渲染"（Progressive Rendering）的方式，以提供更好的用户体验。渐进式渲染允许渲染引擎在仍在下载和解析页面的同时，尽早地显示部分内容在屏幕上，而不必等到整个HTML文档完全解析和构建渲染树后再显示。

### 持续通信阶段

持续通信阶段是浏览器与服务器之间通过维持连接以实现实时数据传输的过程。这一过程可以通过不同的应用层协议来实现，以下是关于不同协议的详细描述：

HTTP：在HTTP/1.1中，服务器可以选择使用Connection: keep-alive来表示愿意保持连接。这意味着一旦建立初始连接，浏览器和服务器之间的TCP连接将保持打开状态，以便实现更实时的数据传输，减少连接建立和断开的开销。而在HTTP/2和HTTP/3中，默认启用了多路复用，无需显式指定Connection: keep-alive。

Websocket：WebSocket是一种全双工通信协议，它通过一个初始HTTP握手来建立连接，其中包含一个特殊的头部字段Upgrade: websocket。服务器在接收到这个请求后，如果支持WebSocket协议，将返回一个HTTP 101 Switching Protocols响应，表示协议切换成功，从而将HTTP连接升级为WebSocket连接。一旦建立WebSocket连接，客户端和服务器之间可以在任何时候互相发送消息，而无需等待请求-响应的模式。为了确保WebSocket连接保持活跃，客户端和服务器可以定期发送心跳消息。心跳消息通常是一个空的文本或二进制帧，用于告知对方连接仍然有效。当客户端或服务器决定关闭连接时，它们可以发送一个特殊的关闭帧来终止连接。WebSocket消除了HTTP的连接建立和关闭开销，提供高性能和效率，适用于实时应用如聊天和游戏。

Server-Sent Events（SSE）：SSE是一种基于HTTP的单向通信协议，服务器通过事件流向浏览器推送数据。浏览器通过一个特殊的EventSource对象并指定 SSE 服务器的端点 URL来建立连接，一旦建立连接，服务器可以实时发送事件数据给浏览器，请求响应头通常会包含`Content-Type: text/event-stream`。SSE适用于需要从服务器向客户端实时传递事件的场景，如实时新闻、股票报价、天气更新等。

MQTT：MQTT是一种物联网设备和应用之间的发布/订阅消息传输协议，是一种单向通信协议。它支持低带宽、高延迟或不稳定网络环境中的高效通信。MQTT主要用于设备间数据传递，支持消息广播和不同Quality of Service（QoS）级别以控制消息可靠性和交付保证。

## 事件处理

浏览器对事件的处理是指浏览器如何捕获、处理和响应用户在网页上执行的各种交互动作，例如点击鼠标、键盘输入、页面加载完成等。以下是浏览器事件处理的详细描述：

* 事件触发：事件可以是用户交互触发的，比如点击、鼠标移动、键盘按键等。也可以是浏览器内部或页面加载过程中触发的，比如页面加载完成、网络请求完成、文档准备就绪等。
* 事件类型：事件可以分为多种类型，如鼠标事件（click、mouseover、mouseout）、键盘事件（keydown、keyup）、表单事件（submit、change）、页面加载事件（DOMContentLoaded、load）、网络请求事件（XMLHttpRequest、fetch）、自定义事件等。
* 事件捕获和冒泡：浏览器事件处理模型支持事件捕获和冒泡两种方式。事件捕获从顶层元素开始，向下逐级检查元素，直到达到触发事件的目标元素。事件冒泡则从目标元素开始，逐级向上冒泡至顶层元素。
*   事件监听器（Event Listeners）：开发者可以通过添加事件监听器来响应特定事件。例如点击事件：element.addEventListener('click', function(event) {

    ```typescript
    element.addEventListener('click', function(event) {
      // 事件处理代码
    });
    ```
* 事件对象（Event Object）：每个事件处理函数都会接收一个事件对象作为参数，该对象包含有关事件的信息，如事件类型、目标元素、鼠标位置、键盘键码等。
* 阻止事件冒泡和默认行为：在冒泡阶段回调中使用event.stopPropagation()来停止事件冒泡，从而防止事件传播到更高级别的元素。在冒泡阶段回调中使用event.preventDefault()可以阻止浏览器内置的默认行为。
* 事件委托（Event Delegation）：事件委托是一种优化事件处理的方法，通过将事件监听器添加到父元素上，然后利用事件冒泡来处理子元素的事件。这种方法可以减少事件监听器的数量，提高性能，特别适用于动态生成的元素或大量相似元素的情况。事件委托通常是在冒泡阶段的回调中执行。
* 内置事件处理程序：浏览器内置了一些默认的事件处理程序，如表单提交、链接点击、鼠标右键菜单等。冒泡阶段回调中使用event.preventDefault()可以阻止这些默认行为。开发者可以通过JavaScript来覆盖或自定义这些默认行为。

事件处理链路从事件触发开始、经过捕获阶段、捕获事件监听器回调、冒泡阶段、冒泡事件监听器回调、事件委托、触发内置事件处理程序。

## 浏览器安全

浏览器安全是维护用户在线安全和隐私的重要方面，它采取了多种措施来抵御互联网威胁：

* 同源策略（Same-Origin Policy）：同源策略是浏览器核心安全机制。它规定了一个网页只能从相同协议（如HTTP或HTTPS）、相同域名和相同端口加载其他资源，以防止恶意网站访问用户的敏感信息。跨源请求需要使用CORS（跨源资源共享）等机制来允许合法的跨源交互。同源策略规定，浏览器只允许在以下情况下加载跨域资源：
  * 协议相同：跨域请求的协议必须与当前页面的协议相同（通常是http或https）。
  * 域名相同：跨域请求的域名必须与当前页面的域名相同，主域名和子域名在同源策略中同样被视为跨域。
  * 端口相同：如果指定了端口号，跨域请求的端口号必须与当前页面的端口号相同。
  *   跨域问题通常出现在以下情况：

      * 不同域名的AJAX请求：通过XMLHttpRequest或Fetch API发起的跨域AJAX请求会受到同源策略的限制。
      * 跨域嵌套：嵌套的iframe、frame或窗口尝试访问父窗口的内容。
      * 跨域资源引用：例如使用标签引入不同域名的JavaScript文件、或者引入不同域名的CSS文件。
      * 为了解决跨域问题，可以采用以下方法：
        * 跨域资源共享（CORS）：服务器可以在响应中添加CORS头部，允许指定的域名或所有域名访问资源。这是一种常见的解决跨域问题的方式。
        * JSONP（JSON with Padding）：通过动态创建标签，从不同域名获取JSON数据，但它有一些安全风险和限制。
        * 代理服务器：在您自己的服务器上设置代理，允许客户端通过您的服务器访问其他域名上的资源。这种方式可以绕过浏览器的同源策略。
        * 跨文档消息传递（postMessage）：用于在不同窗口或iframe之间进行安全的跨域通信。
        * JSON Web Tokens（JWT）：一种将令牌嵌入到HTTP请求头中的身份验证机制，用于跨域身份验证。
        * 跨域设置资源访问策略（CSP）：通过设置CSP头部来限制页面上加载的资源，从而增强安全性。
        * 需要根据具体的情况选择适合的跨域解决方案，以确保数据的安全和完整性。跨域问题不仅仅是浏览器开发中的挑战，也是Web应用程序安全的一部分。


* HTTPS：HTTPS是一种通过使用SSL/TLS加密传输数据的安全通信协议。它确保了数据在传输过程中的机密性和完整性，同时还能防止中间人攻击。使用HTTPS可以确保用户的敏感信息（如密码、信用卡号等）在传输时得到保护。
* 内容安全策略（Content Security Policy，CSP）：CSP是一种安全策略，用于减少跨站点脚本攻击（XSS）的风险。它通过定义哪些来源的脚本和资源可以执行和加载，以限制恶意脚本的执行。
* 跨站点请求伪造（Cross-Site Request Forgery，CSRF）保护：CSRF攻击是一种恶意攻击，利用了用户已经在另一个站点进行了身份验证的事实。浏览器可以通过生成和验证CSRF令牌来防止这种攻击，确保只有合法请求能够成功。
* 安全开发实践：网站和Web应用程序开发者需要遵循安全的开发实践，包括输入验证、避免XSS和SQL注入攻击、适当的身份验证和授权等，以保护其用户免受各种攻击。

此外，现代浏览器还采用了安全沙盒技术，将不同网页和插件隔离在独立的进程中，限制潜在攻击的影响范围。自动更新机制确保用户使用最新版本的浏览器，及时修复已知的安全漏洞。浏览器还警告用户有关不安全的下载和弹窗，以防止恶意软件和欺诈行为。最后，隐私保护方面，浏览器提供隐私浏览模式和追踪阻止器等功能，有助于用户保护个人信息和浏览历史的隐私安全。这些安全措施共同构建了一个安全的在线浏览环境，为用户提供了更多的信心和保护。

## 浏览器存储

##

